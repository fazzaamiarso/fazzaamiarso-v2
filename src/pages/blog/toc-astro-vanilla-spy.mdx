---
layout: "../../layouts/Blog.astro"
title: "Add TOC + Scroll Spy in Astro with Vanilla JS"
description: "Add Table of Content to an Astro blog with Scroll Spying in Vanilla JS"
publishedAt: "2023-01-08"
tags:
    - astro
    - javascript
draft: true
---
import CldImage from "components/mdx/CldImage.astro";
import Notes from "components/mdx/Notes.astro";
import MetaCodeBlock from "components/mdx/MetaCodeBlock.astro";

In a blog, sometimes there is a table of content to help us navigate through the blog easier. When building custom blog with remark and rehype, a common solution is to use `rehype-toc` plugin. 

In Astro, we can build TOC without extra plugin. Astro already provides us with necessary property by default. As an extra touch, we will add scroll spy to keep track on what heading we're currently on.

<Notes>
I will use the astro blog starter template as an example.
</Notes>

## Create the Component
Let's create a new astro component called `TOC.astro` and define the needed props. 

```astro
---
export type Props = {
	pageHeadings : Array<{depth:number,text: string; slug: string }>
}

const { pageHeadings } = Astro.props;
---
<aside id="#toc">
	<ul>{pageHeadings.map(h => {
		return <li> <a href={`#${h.slug}`}>{h.text}</a></li>
	})}</ul>
</aside>

```

The `pageHeadings` props will be a special [`headings`] props passed from astro layout component. Astro automatically assign id to all headings in markdown which become slug in `headings` props.


```ts
[{
    text : "Implement TOC",
    depth : 1,
    slug: "implement-toc"
},
{
    text : "Create Markup",
    depth : 2,
    slug: "create-markup"
}]
```

Insert the TOC to the blog layout and pass it the special  `headings` props

<MetaCodeBlock filename="/layout/BlogLayout.astro">
```astro
---
const {headings} = Astro.props;
---
<body>
	<Header />
		<main>
			<article>
			<h1>{content.title}<h1>
			<hr />
			<slot />
			<TOC pageHeadings={headings} />
			</article>
		</main>
	<Footer />
</body>
```
</MetaCodeBlock>

Let's add a little style to the toc, so it become fixed to the right.

```astro
// /components/TOC.astro
<style>
	#toc {
        position: fixed;
        top: 0;
        right: 5rem;
	}
	ul {
		list-style: none;
	}
	a {
		text-decoration: none;
	}
</style>

```

Here's the result.

<CldImage publicId="toc-initial" alt="table of content initial markup" width="500px" />

The TOC is working and sufficient for most use cases. But, we will enhance it with scroll spy, that will highlight the active heading.

## Scroll Spy with Intersection Observer
We must let the TOC know which heading are active by observing/spying the heading with Intersection Observer.

### Add observer callback function
Firstly, insert a script tag in the TOC file. Afterward, create the observer callback function that's responsible for detecting and setting the active state.

```astro
// /components/TOC.astro

<script>
const setCurrentHeading : IntersectionObserverCallback = (entries) => {
	// loop to each entries (headings) in the page
	for (let entry of entries) {
	// equivalent to the slug returned from pageHeadings
	const { id } = entry.target;
	// get the toc link's element for the current entry
	const tocLinkEl = document.querySelector(`#toc a[href='#${id}']`);
	if(!tocLinkEl) return;
	}
}
</script>
```

What the above code doing is looping through each entries and selecting the link element. It also have guard in case the link element doesn't exist which is unlikely.

Then, add the active styling to the intersecting entry.

```ts
// check if the entry is intersecting
if (entry.isIntersecting) {
// remove active class from all links
document.querySelectorAll("#toc a").forEach((e) => e.classList.remove("active"));
// add active class to the currently active entry
tocLinkEl.classList.add("active");
}
```

Here's the active class for this example.
```css
a.active {
	color: red;
	font-weight: 600;
}
```

### Observer Option
Now that the callback is created, let's also define the option. 
```astro
const observerOptions = {
	threshold: 1,
	rootMargin : "0px 0px -66%"
}
```
Here's the explanation for the option.
- `threshold: 1`  means we want register the element as entry when the element is fully visible.
- `rootMargin: "0px 0px -66%"` means we want to extends the element's bounding box at the bottom.  It's useful because we want the entry to be active when user already scroll quite a bit pass the heading.

### Observe the Headings
Now, we have all the pieces needed to create an observer instance to observe the headings.
```ts
const observer = new IntersectionObserver(setCurrentHeading, observerOptions);

// select all headings to be observed
const elToObserve = document.querySelectorAll("article :is(h2,h3)")

// finally, observe the elements
elToObserve.forEach(el => observer.observe(el))
```

What the code doing is select all headings that we want to observe. Then, loop through each headings and observe them by calling `observe()`.

Here's the final result.

[]

You can also see how I implement it [in my blog]() with TailwindCSS and Sticky positiong.